# DiceyLua

## Lua 虚拟机及 API

**第一步自然是要分析 Lua 的数据结构啦**

类似于 Java，也是先编译成字节码，再由解释器（Lua 虚拟机）解释运行

Lua 的字节码载体（类似于 Java 的 class 文件）为二进制 chunk， 内部还有常量池 行号表等

但是与 Java 不同，Lua 解释器是在内部进行编译，不像 Java 一样会出现显式的 class 文件，这也使得预编译并不会加快脚本执行速度，但会加快脚本的加载速度，一定程度上加快了脚本加载速度

将 Lua 源码编译成 chunk 的工具是 luac

### 二进制 Chunk

Lua 编译器以函数为单位进行编译,每一个函数都会被 Lua 编译器编译为一个内部结构, 即原型(Prototype)

原型主要包含六部分内容:

- 函数基本信息(参数变量 局部变量数量等)

- 字节码

- 常量表

- Upvalue 表

  如果函数f2定义在函数f1中，那么f2为f1的内嵌函数，f1为f2的外包函数，外包和内嵌都具有传递性，即f2的内嵌必然是f1的内嵌，而f1的外包也一定是f2的外包。

  内嵌函数可以访问外包函数已经创建的局部变量，而这些局部变量则称为该内嵌函数的外部局部变量（或upvalue）

- 调试信息

- 子函数原型列表

#### 数据类型

二进制 chunk 本质上来说是一个字节流, 我们需要将其编码为一个或多个字节的信息单位,即得到数据类型

数据类型有三种

- 数字

  在 chunk 中按照固定长度存储.其对应 go 语言类型以及占用字节如下表

  - 字节: 存放一些比较小的整数值,如 Lua 版本号,函数的参数个数等.
  - C 语言整型:主要用来表示列表长度
  - C 语言 size_t:主要用来表示字符串长度
  - Lua 整数:常量表
  - Lua 浮点数: 常量表

  | 数据类型      | Go 语言类型 | 占用字节 |
  | ------------- | ----------- | -------- |
  | 字节          | byte        | 1        |
  | C 语言整型    | uint32      | 4        |
  | C 语言 size_t | uint64      | 8        |
  | Lua 整型      | int64       | 8        |
  | Lua 浮点型    | float64     | 8        |

- 字符串

  本质上是一个字节数组, 还需记录下字节数组的长度, 还可以分为短字符串和长字符串两种

  - NULL 字符串, 0x00 来表示
  - 长度小于等于 253 (0xFD), 先使用一个字节记录长度+1,然后是字节数组
  - 长度大于等于 254 (0xFE), 第一个字节是 0xFF ,后面跟一个 size_t 记录长度+1,最后是字节数组

- 列表

  指令表,常量表,子函数原型表等信息都是按照列表的方式存储的. 先是一个 cint 记录列表长度,紧接着存储 n 个列表元素

#### 头部结构

- 签名: 即魔数, 为 ESC L u a 的 ASCII 码, 即0x1B4C7561, 写成 Go 语言字符串字面量是"\x1bLua"
- 版本号: 实际上是大版本乘 16 再加小版本, 例如5.3.4版本实际存储结果为 5x16 + 3 = 83,存为 16 进制为0 x53
- 格式号: 二进制 chunk 的格式号, 检查是否与虚拟机匹配
- LUAC_DATA: 也是一组魔数, 校验用
- 整数和 Lua 虚拟机指令宽度: 检测上面所提到的数字类型其占用字节是否与预期一致
- LUAC_INT: 使用 n 个字节固定存放 0x5678, 这里的 n 为上条所提到**整数指令宽度**. 使用该数字校验大小端
- LUAC_NUM: 使用 n 个字节存放370.5. 为了检验浮点数格式,一般为 IEEE 754格式

#### 函数原型

见上二进制 Chunk 部分

- 源文件名: 记录二进制 chunk 是由哪个源文件编译出来的.即文件来源
- 起止行号: 两个 cint. 主函数的值为 0
- 固定参数个数
- 是否是 Vararg 函数
- 寄存器数量: Lua 虚拟机是基于寄存器的虚拟机, 大部分指令也都会涉及虚拟寄存器的操作, 因此需要记录数量
- 指令表: 每条指令 4 字节
- 常量表: 包括 nil 布尔 整数 浮点数 字符串 五种. 其分别有对应 tag
- Upvalue 表
- 子函数原型: 没有子函数时为 0
- 行号表: 行号与指令表中的指令一一对应
- 局部变量表: 每个元素都包含变量名和起止指令索引 
- Upvalue 名列表: 其中元素与 Upvalue 表中的一一对应

### 指令集

